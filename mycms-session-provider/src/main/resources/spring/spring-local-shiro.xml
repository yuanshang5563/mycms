<?xml version="1.0" encoding="UTF-8"?>    
<beans xmlns="http://www.springframework.org/schema/beans"    
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   
    xmlns:p="http://www.springframework.org/schema/p"  
    xmlns:aop="http://www.springframework.org/schema/aop"   
    xmlns:context="http://www.springframework.org/schema/context"  
    xmlns:jee="http://www.springframework.org/schema/jee"  
    xmlns:mvc="http://www.springframework.org/schema/mvc"  
    xsi:schemaLocation="    
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.1.xsd  
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd  
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd  
        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.1.xsd  
        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"> 

    <aop:config proxy-target-class="true"/>

    <!-- 会话ID生成器 -->
    <bean id="sessionIdGenerator" class="org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator"/>

    <bean id="limitRetryHashedMatcher" class="com.lenxeon.ucenter.session.shiro.local.LimitRetryHashedMatcher">
        <!--这个配置要和PassWordUtils里一致-->
        <property name="hashAlgorithmName" value="md5"></property>
        <property name="hashIterations" value="2"></property>
        <property name="storedCredentialsHexEncoded" value="true"></property>
    </bean>

    <!-- Shiro默认会使用Servlet容器的Session,可通过sessionMode属性来指定使用Shiro原生Session -->
    <!-- 即<property name="sessionMode" value="native"/>,详细说明见官方文档 -->
    <!-- 这里主要是设置自定义的单Realm应用,若有多个Realm,可使用'realms'属性代替 -->

    <!-- 会话DAO -->
    <bean id="sessionDAO" class="com.lenxeon.ucenter.session.shiro.local.RedisSessionDAO">
        <property name="sessionIdGenerator" ref="sessionIdGenerator"/>
        <property name="expire" value="1800000"/>
    </bean>

    <!--<!– 会话验证调度器 –>-->
    <!--<bean id="sessionValidationScheduler"-->
          <!--class="com.lenxeon.ucenter.user.shiro.shiro.QuartzSessionValidationScheduler">-->
        <!--<property name="sessionValidationInterval" value="1800000"/>-->
        <!--<property name="sessionManager" ref="sessionManager"/>-->
    <!--</bean>-->

    <!-- 会话ID生成器 -->
    <bean id="sessionFactory" class="com.lenxeon.ucenter.session.shiro.local.UserSessionFactory"/>

    <!-- 会话管理器 -->
    <bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
    <!--<bean id="sessionManager" class="org.apache.shiro.session.mgt.DefaultSessionManager">-->
        <property name="globalSessionTimeout" value="1800000"/>
        <property name="deleteInvalidSessions" value="true"/>
        <property name="sessionValidationSchedulerEnabled" value="true"/>
        <!--<property name="sessionValidationScheduler" ref="sessionValidationScheduler"/>-->
        <property name="sessionDAO" ref="sessionDAO"/>
        <property name="sessionFactory" ref="sessionFactory"/>
        <property name="sessionIdCookie.path" value="/"/>
    </bean>

    <dubbo:reference id="userService" interface="com.lenxeon.ucenter.user.api.UserService" version="1.0.0"/>

    <!-- 继承自AuthorizingRealm的自定义Realm,即指定Shiro验证用户登录的类为自定义的ShiroDbRealm.java -->
    <bean id="myRealm" class="com.lenxeon.ucenter.session.shiro.local.UserRealm">
        <property name="userService" ref="userService"></property>
        <property name="credentialsMatcher" ref="limitRetryHashedMatcher"></property>
    </bean>

	<!-- 
    <bean id="cacheManger" class="com.lenxeon.ucenter.session.shiro.local.RedisCacheManager"/>
 	-->
    <!--<bean id="securityManager" class="com.lenxeon.ucenter.user.shiro.MyDefaultSecurityManager">-->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realms">
            <list>
                <ref bean="myRealm"/>
            </list>
        </property>
        <!-- 
        <property name="cacheManager" ref="cacheManger"/>
        -->
        <property name="sessionManager" ref="sessionManager"/>
    </bean>

    <!-- 保证实现了Shiro内部lifecycle函数的bean执行 -->
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

    <!-- 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 -->
    <!-- 配置以下两个bean即可实现此功能 -->
    <!-- Enable Shiro Annotations for Spring-configured beans. Only run after the lifecycleBeanProcessor has run -->
    <!-- 由于本例中并未使用Shiro注解,故注释掉这两个bean(个人觉得将权限通过注解的方式硬编码在程序中,查看起来不是很方便,没必要使用) -->

    <!-- Support Shiro Annotation -->
    <!--<bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">-->
    <!--<property name="exceptionMappings">-->
    <!--<props>-->
    <!--<prop key="org.apache.shiro.authz.UnauthorizedException">shiro-test/refuse</prop>-->
    <!--</props>-->
    <!--</property>-->
    <!--</bean>-->

    <!--<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"-->
    <!--depends-on="lifecycleBeanPostProcessor"/>-->
    <!-- -->

    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"/>
    </bean>

    <!-- 相当于调用SecurityUtils.setSecurityManager(securityManager) -->
    <bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
        <property name="staticMethod" value="org.apache.shiro.SecurityUtils.setSecurityManager"/>
        <property name="arguments" ref="securityManager"/>
    </bean>
</beans>